약 4주 가량 진행한 자바스크립트 스터디의 마지막 챕터인 **비동기 통신**파트 입니다. 
자바스크립트로 정말 다양한 일을 할 수 있지만 이번 스터디에서는 손쉽게 DOM요소를 조작하는 방법과 
각종 API를 활용하기 위해 비동기 통신을 이용한 데이터 처리 방식을 소개하면서 마무리하려고 합니다. 
이번 챕터에서는 자바스크립트의 사용법뿐만 아니라 웹 개발에 필요한 여러가지 지식이 등장하게되어, 
별도의 설명이 없으면 헷갈릴만한 내용들이 나올 수도 있으니 본 문서를 참고해주시기 바랍니다. 
그럼 마지막 챕터를 시작해봅시다. 

## 1. 비동기 통신

웹 개발을 하면서 사용자의 입력을 받아 처리한다고 해봅시다. 예시로는 로그인 정도로 들 수 있겠습니다.
로그인을 처리하려면, `<form>`태그를 만들고 그 안에 `<input>`태그를 만들어 사용자가 값을 입력하면
`<button>`태그 중 submit 속성을 이용하여 서버에 값을 전달하고, 서버에서 그 값을 처리하는 방식으로 
진행할 것입니다. 이 과정에서 `<form>`태그의 submit행위는 필수적으로 화면의 깜빡임을 일으킵니다. 
`<form>`의 내용을 서버에 전달하고 새로 문서를 읽어오기 떄문입니다. 이러한 행위를 따로 부르지는 않지만 
전송과 수신이 동시에 일어나니 **동기적(synchronous)**이라고 할 수 있겠습니다.

**비동기적(asynchronous)**통신은 `<form>`태그를 이용하는 방법과 전체적인 맥락은 비슷하지만 크게 
다르지 않습니다. `<form>`태그를 이용해 직접 서버에 데이터를 전송하는 방식이 아니라, 자바스크립트를 이용해 
값을 서버에 전송하고, 결과가 돌아오면 특정 이벤트를 발생시켜 해당 이벤트에서 결과를 받아보는 방식입니다. 
이를 **AJAX(Asynchronous Javascript And XML)**방식이라고도 합니다. 

이 비동기 통신은 '자바스크립트를 이용해 값을 서버에 전송한 뒤에, **결과가 돌아오면 이벤트를 발생시킨다**'
라는 점이 가장 주요한 특징입니다. 이 말은 풀어서 이야기하면, '**화면 깜빡임 없이 서버에 데이터를 전송한다**'라는 말입니다. 
이러한 이점 덕분에 페이스북, 인스타그램 같이 스크롤에 따라 화면깜빡임 없이 데이터를 무제한 로드하는 등의
UI를 제작할 수 있는 것입니다. 

### 1.1. 비동기 통신을 사용하기 전에 

비동기 통신을 사용하기 전에 알아두어야 할 것이 몇가지 있습니다. 이번에 다룰 예제에서도 필요한 내용이며, 
앞으로 실전에서 비동기 통신을 사용할 떄도 종종 사용하게 될 자바스크립트와 jQuery팁 입니다. 

#### 1.1.1. http? 

비동기 통신을 하려면 http가 무엇인지는 알고 있어야합니다. 우리는 데이터 통신에 대해서 깊게 배우는 것은 
아니기 때문에 깊게 언급하지는 않겠습니다. http는 통신 규약입니다. 우리의 프로그램이 설치되어있는 서버와 
사용자들이 다움받아 확인 할 수 있는 클라이언트간의 통신에 대한 약속인 것입니다. 

보통 웹에 접속을 하기 위해 브라우저에 주소를 입력하면, 사용자(client)는 해당 주소로 문서를 요청하게 되고
서버는 그 주소에 해당하는 문서를 반환합니다. 그 이후 페이지를 이동하거나, 로그인을 요청하는 등의 행위를 
할때에도 모두 해당 주소와 http가 사용되는 것입니다. 

비동기 통신은이 http 통신은 자바스크립트로 발생시키고 문서를 돌려받거나 혹은 **데이터 만을 돌려받기도 합니다**

#### 1.1.2. http method?

그리고 Http에는 method라는 것이 있습니다. 혹시 선행하여 개발을 진행해보셨다면 "'GET'방식으로 보낸다." 혹은 
"'POST'방식으로 전송한다." 따위의 말을 들어보셨을 수 도 있습니다. 이는 http의 전송 타입을 의미합니다. 

'GET'과 'POST'의 차이는 말그대로 값을 전송하는 방식에서 차이가 납니다. 'GET'은 **쿼리스트링**이라고 불리는 
방식을 이용해 서버에 데이터를 전송하게 됩니다. 쇼핑몰 등에서 아래와 같은 주소 형태를 보신 적 있을 것 입니다.

`http://www.shop.com/list?category=notebook&page=2`

위의 주소에서 `?category=notebook&page=2`부분이 쿼리스트링입니다. 주소와 `?`표기로 구분되며,
`키=값`형태로 데이터를 이루고 각 데이터들은 `&`표기로 구분합니다. 주소에 데이터를 실어 보내는만큼 해당 방법을 
사용했을 때에는 보낼 수 있는 데이터의 양이 상당히 제한됩니다. 본 방식의 이점은 조금 실무적인 부분에서 드러납니다. 

쇼핑몰을 사용한다고 했을 때, 우리는 종종 다른 사람들에게 상품 정보를 링크로 넘겨주고 상품에 대해 간단히 이야기 
나누어 구입을 결정하곤 합니다. 우리가 보고있는 화면을 다른 사용자가 똑같이 확인하는게 너무 당연한 일이지만, 
사실 여기에도 http와 'GET'방식이 숨어있습니다. 

`http://www.shop.com/detail?id=123nsacASCN3`

위 같은 주소가 있다고 가정해봅시다. 위의 주소는 `www.shop.com`이라는 사이트에서 `/detail`이라는 주소의 
페이지를 불러오되, `id=123nsacASCN3`라는 쿼리스트링을 서버에 같이 넘겨줍니다. 이를 통해서 `/detail`에서는 
'id'가 주어진 값과 같은 상품을 불러와 내용을 채워넣고 사용자에게 응답하는 것입니다. 

보통 다른 http 소개글에서는 POST와 GET은 '보안'의 차이라며 이야기를 하는데 'GET'또한 많은 이점이 있기 때문에
'보안'이라는 이야기를 듣고 모든 데이터 처리를 POST로 처리하는 것은 옳은 방법은 아니기에 짚고 넘어갑니다.

위 같은 'GET'방식 이외에 'POST' 방식이 있습니다. POST는 `<form>`태그에 `<input>`으로 데이터를 실어 보냈듯이
http의 `body`라는 영역에 데이터를 실어서 보냅니다. html이 header / body / footer로 나뉘듯이 http도 

크게 나누면 head영역과 body영역이 있습니다. head 영역에는 주로 주소, meta 정보들이 실리게 됩니다. 
위에서 다룬 GET 방식은 주소를 조작해 요청하는 방식이므로 head영역을 이용해 데이터를 첨부한다고 할 수 있겠습니다. 
그에 반에 POST방식을 http의 body영역을 사용합니다. 이는 요청을 중간에 뜯어보지 않는다면 GET 방식 처럼 값이 
드러나지 않습니다. 그리고 body 영역은 head보다 굉장히 많은 양의 데이터를 요청 할 수 있게됩니다. 이 방식의 예시로 
파일 업로드 혹은 글 게시 정도가 있겠습니다. 

이 처럼 http에는 다양한 규약이 있고 대표적으로 GET / POST를 사용하고 있다는 점은 알아두어야 추후에 API를 
이용하거나 개발할 때 참고할 수 있을 것입니다. 많이 나오는 이야기이니 꼭 읽어보고 넘어가셨으면 합니다.

#### 1.1.3. callback , 익명 함수의 활용

우리는 이전 과정에서 자바스크립트의 다양한 특성에 대해서 배웠습니다. 그 중 하나가 바로 함수였습니다. 자바스크립트에서는 
자료형이 굉장히 다양한 방법으로 사용될 수 있었고, 심지어 함수의 인자로서 함수 자체를 넘기거나 반환형으로 함수를 반환하는 등의
다양한 활용법이 준비되었습니다. 이번 코드에서는 이 함수의 용법을 이해해야하는 부분이 많이 언급됩니다. 

```javascript
function fn(callback){
  console.log('Hello');
  callback();
}

function fn2(){
    console.log('World!');
}

fn(fn2); // Hello // World!
```

위의 코드를 실행하면 무슨 일이 일어날까요? 브라우저에서 개발자 콘솔에 본 코드를 실행해본다면 아마 결과는 'Hello','World!'라고 
각각 다른 줄에 출력하게 될 것입니다. fn함수의 `console.log`함수가 실행 되고 난 뒤에 fn2함수의 `console.log`함수가 
실행되었다고 볼 수 있겠습니다. 위의 코드 구조는 **fn 함수가 fn2함수를 인자로** 넘겨 받고 본인의 처리가 끝난 뒤에, 인자로 
**넘겨받은 함수를 실행한 행위** 입니다. fn이 인자로 넘겨받은 fn2함수는 fn안에서 파라미터 이름인 `callback`이라는 이름으로 쓰이고 
있습니다. 그리고 `callback()`이라는 한줄을 이용해 넘겨받은 함수를 실행해주고 있습니다. 이렇듯 `fn`함수에서 `callback`이라는 
이름으로 **넘겨받은 함수 인자를 실행해주지 않는다면, fn2는 절대 실행되지 않습니다.** 단순히 함수를 넘겨주는 것만으로는 인자로 
넘긴 함수를 실행할 수 없습니다. 

이렇게 함수1이 함수2를 인자로서 넘겨받고, 함수1의 업무가 **모두 종료된 뒤에** 함수2를 실행하는 구조를 **callback**방식이라고 합니다. 
함수1의 수행내용이 끝났는지 확실히 알아두어야 하는 경우에 이런 구조를 사용하곤합니다. 사용자의 요청이나, 비동기 통신 등 요청을 보내고 
결과가 코드 순서와 상관없이 비동기적으로 결과를 반환하는 경우에 사용됩니다. 이 경우는 아래의 예제에서 다루게 될 것입니다. 

문제는 위의 구조가 다른 방식으로도 선언될 수 있다는 점입니다. 

```javascript
function fn(callback){
    console.log('Hello');
    callback();
}

fn(function(){
  console.log('World!');
});
```

지금의 코드와 처음 소개한 코드의 차이점은 무엇일까요? 익명 함수를 사용하냐 안하냐의 차이라는 것이 한눈에 보였으면 좋겠습니다. 
fn이라는 함수는 처음 소개한 코드와 동일하게 함수를 `callback`이라는 이름의 인자로 넘겨받고 있습니다. 그리고 본인의 업무가 
완전히 종료된 뒤에 넘겨받은 `callback`이라는 함수를 실행해주고 있습니다. 

그런데 여기서 fn의 실행부에는 선언된 함수를 넘기는 것이 아닌 **익명함수**를 넘겨주고 있습니다. 따로 함수를 선언하지 않고 
함수의 실행부에 함수 자체를 선언해놓은 것입니다. 이 익명함수는 fn 함수에 넘겨졌을때 `callback`이라는 이름으로 
**fn함수가 실행해주어야만 실행되는 것입니다.** 다만 위의 코드와 다른 점은 따로 함수를 선언해 가지고 있지 않는다는 점입니다. 

이 익명함수는 fn함수가 실행될 때만 선언되어 사용되고 fn함수가 callback을 실행하고 나서 fn함수가 종료되고 나면 그 이후에는 
사라지게 되고, 매번 fn함수가 실행될 때 동일한 프로세스를 반복하게 됩니다. 

이러한 구조는 특수한 이벤트 이외에는 함수를 사용하지 않는 경우에 많이 사용됩니다. 특히 이런 callback 구조에서 특히 더 많이 
사용되곤 합니다. 지금은 많이 사장된 기술으로 `promise`로 많이 대체 되었으나, 지금도 충분히 많이 사용하는 기법이므로 
기억해두고 넘어가는 것이 좋습니다. 

### 1.2. 비동기 통신의 사용

비동기 통신을 사용하기 위해서 우리는 jQuery의 `ajax`함수를 사용할 것입니다. 예제를 먼저 확인해봅시다. 

```javascript
/// example.html , example.js 참조
// 웹이 모두 로드되었을 때(ready state일 때) 본 내용이 실행되도록함 
$(document).ready(function(){
    var __tbody = $('#tblPeople').find('tbody');
    var __rowMockup = $('.mockup').find('tr');
    
    // $ === jQuery
    // $.ajax({...}).then(성공했을 때 , 실패했을 때);
    console.log('request asynchronous');
    $.ajax({
        url : 'http://syunoti.cafe24app.com/API/boards/example',
        method : 'get'
    })
    .then(function(res){
        // 통신이 성공한 경우 
        console.log(res.data);
        console.log('asynchronous responsed');
        if(__tbody.children().length > 0){
            // table body에 내용이 하나라도 있다면 
            __tbody.children().remove();
        }
        for(var i = 0 ; i < res.data.length ; i++){
            // 받아온 데이터들을 하나씩 읽으면서 row를 생성함
            let row = __rowMockup.clone();
            let person = res.data[i];
            row.find('.seq').text(person.seq);
            row.find('.name').text(person.name);
            row.find('.hp').text(person.hp);
            row.find('.email').text(person.mail);
            row.find('.grade').text(person.grade);
            row.find('.age').text(person.age);
            // 그리고 만들어진 row를 tbody에 append한다. 
            __tbody.append(row);
        }
    } , function(){
        // 통신이 실패한 경우
        console.log('ERROR!!');
    })
    console.log('Hello');
});
```

다소 어려울 수 있겠지만 위의 코드를 짚어봅시다. 비동기 통신에 대한 코드지만, 먼저 스크립트의 가장 첫 째 줄을 
언급하고 넘어가야할 것 같습니다. 

#### 1.2.1. html로드와 자바스크립트 실행

위의 코드는 `$(document).ready(function(){})`라는 큰 구조 안에 선언되어있습니다. 이는 간단히 이야기하자면,
'HTML의 모든 요소가 로드되고 나면 알아서 실행하는 함수 구문'이라고 할 수 있겠습니다. 알아서 실행된다고 하는 부분은 
ready라는 함수안에 있는 `function(){}`이라 써있는 익명함수가 자동으로 실행되는 것입니다. 이 구조는 우리가 위에서 
다뤘던 `callback`구조와 완전히 동일합니다. document라는 요소를 jQuery로 셀렉트하고, ready라는 함수를 실행하면 
그 함수의 인자로 들어간 익명 함수인`function(){}`부분을 등록해두었다가 모두 로드되었을때 넘겨준 익명함수가 실행되는 
방식이기 때문입니다. 

이 코드를 jQuery없이 사용한다면 다음과 같이 구현될 것입니다.
```javascript
document.addEventListener("DOMContentLoaded", function(event) { 
  //do work
});
```
이 코드는 `DOMContentLoaded`라는 이벤트가 발생됐을때 두번째 인자로 넘긴 익명함수가 실행되도록 하는 코드입니다.
이벤트가 발생할 때 실행될 함수를 선언한다는 것은, 사용자 혹은 페이지가 언제 발생시킬지 모르는 비동기 적인 행위를 
담당하는 것과 같기 때문에 함수를 인자로 넘겨주어 `callback`형식으로 처리하는 것 입니다. 

이외에도 `$(function(){})`같은 코드로 대체할 수 있습니다. 

#### 1.2.2. $.ajax

길고 긴 설명을 지나 드디어 본론으로 넘어오게 되었습니다. 우리는 비동기 통신을 사용하기 위해 jquery에서 제공하는 
함수인 `jQuery.ajax`함수를 사용할 것 입니다. 이 함수에서 사용되는 모든 인자와 정보는 jquery의 개발 문서에서 
다루고 있으며, 본 스터디에서는 일부 필요한 인자만 먼저 설명하겠습니다. 

예제코드를 설명하기 앞서 `jQuery.ajax` 함수가 무엇인지 먼저 알아봅시다. 앞서 말씀드렸듯이 비동기 통신은 
비동기적인 http요청을 발생시키고 결과가 돌아오면 자동으로 결과를 반환하는 방식입니다. 요청을 보내고 넘겨받는 
과정은 위에서 언급한 `callback`과 거의 유사한 방식으로 실행 됩니다. 아래의 코드로 설명하겠습니다.

```javascript
function request(){
 console.log('1');
 $.ajax(/*필요한 인자*/).success(function(){
   console.log('2');
 });
 console.log('3');
}

request();
```

위와 같은 코드를 입력했을 때, `console.log`는 어떤식으로 실행될까요? 아마 이전의 내용을 가지고 생각해본다면
1 -> 2 -> 3 순으로 한줄씩 출력될 것이라 예상해 볼 수 있겠습니다. 하지만 실제로 ajax를 이용해 함수를 실행해보면,
1 -> 3 -> 2 순으로 실행되는 것이 보통일 것입니다. 이유를 살펴봅시다. 

첫째 실행되는 `console.log('1')`은 예상한듯이 request함수가 실행되고 나면, 제일 먼저 실행되는 것이 맞습니다. 
문제는 `$.ajax`구문입니다. `$.ajax`라는 함수는 실행하는 즉시 비동기 요청을 일으킵니다. 그리고 success라는 함수가 
넘겨받은 익명 함수는 이 요청에 대한 응답이 돌아오기 전까지 실행이 연기됩니다. (callback을 떠올려봅시다.)
이때 request 함수는 응답이 돌아오기까지 다음 코드의 실행을 기다리지 않습니다. 그냥 지나쳐가버립니다. 그렇기 떄문에 
`console.log('3')`이 먼저 실행되게 됩니다. 만약 정말 빠른 응답이 와서 `console.log('2')`가 먼저 실행될 수도 
있겠으나, 그런 경우는 거의 없다고 생각됩니다. 

이렇듯 비동기 요청은 화면의 깜빡임이 없는 화면상의 비동기적인 요청을 할 뿐만 아니라, 코드 상에서도 비동기적인 이벤트로서 
취급되기 때문에, 코드를 작성할 때 유의해야 합니다.

#### 1.2.3. $.ajax의 인자와 then

이렇듯 `$.ajax`는 비동기 요청을 보내게 되는데, 이 함수가 넘겨받는 인자에 대해서 간단하게 알아봅시다.

```javascript
$.ajax({
  url : 'http://www.abc.com',   // 요청을 보낼 주소입니다.
  method : 'GET',               // 요청 방식입니다. 
  data : {},                    // 넘겨줄 데이터 입니다. GET이라면 쿼리스트링으로, POST라면 body로 넘겨줍니다. 
})
// 첫쨰인자는 성공, 둘째는 실패 
.then(function(res){
    console.log('성공' , res);
},function(){
    console.log('실패')
})
```

위처럼 원하는 통신 방식과 주소, 데이터를 넘겨주어 서버에 요청하게 됩니다. 그리고 이 요청을 보내고 나서 결과를 받을떄는 
`then`함수를 사용하곤합니다. 이 함수는 인자로서 **두개의 함수**를 넘겨 받습니다. 첫번쨰함수는 성공시 실행되는 함수, 
두번째 함수는 실패시 실행되는 함수입니다. 이 익명함수들에게는 then함수 측에서 응답이 담긴 객체를 추가로 넘겨주기 떄문에,
익명함수 측에서 이를 인자로 받아 사용할 수 있습니다. 조금 복잡하게 들리겠으나 아래와 같은 경우라고 생각하시면됩니다.

```javascript
function fn1(callback){
    callback('Hello World');
}

function fn2(word){
    console.log(word);
}

fn1(fn2); // Hello World
```

위와 같은 구조로 `then`함수를 선언하고 나면 비동기 통신이 끝났을때 넘겨준 함수들이 요청값을 가지고 데이터를 처리하게 됩니다.
응답에 들어있는 내용은 서버에서 제공하는 방식마다 모두 다르기때문에 별도로 확인할 필요가 있습니다. 

`then`함수는 필요에 따라서는 `$.ajax().success()`와 `$.ajax().erorr()`혹은 아래와 같이 대체할 수 있습니다. 이떄 
then함수는 `promise`방식이라고 부르고, `success , error`방식은 `callback`이라 부르나 상세한 내용은 기회가 되면 
따로 다루도록 하겠습니다. 

```javascript
$.ajax({
    url : 'http://www.example.com',
    method : 'GET',
    data : { key : 'value' },
    success : function(res){ console.log(res); },
    error : function(res){ console.log(res); }
})
```

#### 1.2.4. 정리

위 코드에서는 `$.ajax`를 사용하고 있으며, `then`함수를 통해 성공과 실패처리를 해주고 있습니다. 성공했을때에 요청 데이터를 
다루는 방법은 해당 코드를 확인해보시면 됩니다. 


### 마치며 

본 내용은 중급자정도로 다소 어려운 내용입니다. 상세하게 적어두긴 했지만 많이 어려우실 수 있겠습니다. 실제로 코드를 작성하실떄에는 
본 문서를 참고해가며 작성하시면 조금은 도움이 되실 것이라 생각됩니다. 이번에 준비된 practice는 여태 준비해드린 연습문제 중 가장 
어렵게 작성되었습니다. 실제 제가 코드를 작성하는 방식을 그대로 따르고 있고, 언급되지 않은 선언 방식등이 사용되고 있습니다. 

본 연습 문제는 스터디원 한명 한명 코드를 리뷰해드리고 설명해드리고 있으니, 연습문제를 최대한 풀어보시고 안되신다면 solution 파일을 
분석해보는 식으로 진행해주시면 좋겠습니다. solution코드를 분석하신다면 함수가 실행되는 순서대로 코드를 되짚어 보시는 것을 추천해드립니다. 

약 한달여간 스터디를 진행했는데, 도움이 많이 되셨는지 모르겠습니다. 추후에 심화 과정으로 뵐 수 있으면 다시 뵙겠습니다. 모두 고생많으셨습니다.


